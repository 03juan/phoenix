// Generated by CoffeeScript 1.7.1
(function() {
  this.Phoenix = {};

  this.Phoenix.Socket = (function() {
    Socket.prototype.conn = null;

    Socket.prototype.endPoint = null;

    Socket.prototype.subscriptions = null;

    Socket.prototype.awaitingJoins = null;

    function Socket(endPoint) {
      this.endPoint = endPoint;
      this.subscriptions = [];
      this.awaitingJoins = [];
      this.connect();
    }

    Socket.prototype.connect = function() {
      this.conn = new WebSocket(this.endPoint);
      this.conn.onopen = (function(_this) {
        return function() {
          _this.subscribeAll();
          _this.joinAll();
          return _this.onOpen();
        };
      })(this);
      this.conn.onerror = (function(_this) {
        return function(error) {
          return _this.onError(error);
        };
      })(this);
      return this.conn.onmessage = (function(_this) {
        return function(event) {
          return _this.onEvent(event);
        };
      })(this);
    };

    Socket.prototype.onOpen = function() {};

    Socket.prototype.subscribeAll = function() {
      var sub, _i, _len, _ref, _results;
      _ref = this.subscriptions;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        sub = _ref[_i];
        _results.push(this.subscribe(sub));
      }
      return _results;
    };

    Socket.prototype.joinAll = function() {
      var join, _i, _len, _ref, _results;
      _ref = this.awaitingJoins;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        join = _ref[_i];
        _results.push(this.join(join));
      }
      return _results;
    };

    Socket.prototype.join = function(channel, topic, callback) {
      this.awaitingJoins.push({
        topic: topic,
        callback: callback
      });
      return this.send({
        channel: channel,
        event: "join",
        message: {
          topic: topic
        }
      });
    };

    Socket.prototype.send = function(_arg) {
      var channel, event, message;
      channel = _arg.channel, event = _arg.event, message = _arg.message;
      return this.conn.send(JSON.stringify({
        channel: channel,
        event: event,
        message: message
      }));
    };

    Socket.prototype.onError = function(error) {
      return typeof console.log === "function" ? console.log("WS: " + error) : void 0;
    };

    Socket.prototype.subscribe = function(channel, topic, callback) {
      return this.subscriptions.push({
        channel: channel,
        topic: topic,
        callback: callback
      });
    };

    Socket.prototype.unsubscribe = function(channel, topic) {
      var index, sub, _i, _len, _ref, _results;
      _ref = this.subscriptions;
      _results = [];
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        sub = _ref[index];
        if (sub.channel === channel && sub.topic === topic) {
          _results.push(this.subscriptions.splice(index, 1));
        }
      }
      return _results;
    };

    Socket.prototype.onEvent = function(event) {
      var channel, eventData, message, topic;
      eventData = JSON.parse(event.data);
      console.log(eventData);
      channel = eventData.channel, topic = eventData.topic, event = eventData.event, message = eventData.message;
      switch (event) {
        case "join:success":
          return this.triggerAwaitingJoinSuccess(topic, message);
        case "join:failure":
          return this.triggerAwaitingJoinFailure(topic, message);
        default:
          return this.triggerSubscriptionCallback(channel, topic, message);
      }
    };

    Socket.prototype.triggerSubscriptionCallback = function(channel, topic, message) {
      var index, sub, _i, _len, _ref, _results;
      _ref = this.subscriptions;
      _results = [];
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        sub = _ref[index];
        if (sub.channel === channel && sub.topic === topic) {
          _results.push(typeof sub.callback === "function" ? sub.callback(message) : void 0);
        }
      }
      return _results;
    };

    Socket.prototype.triggerAwaitingJoinSuccess = function(joinedTopic, message) {
      var callback, index, topic, _i, _len, _ref, _ref1, _results;
      _ref = this.awaitingJoins;
      _results = [];
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        _ref1 = _ref[index], topic = _ref1.topic, callback = _ref1.callback;
        if (!(topic === joinedTopic)) {
          continue;
        }
        if (typeof callback === "function") {
          callback(null, message);
        }
        _results.push(this.awaitingJoins.splice(index, 1));
      }
      return _results;
    };

    Socket.prototype.triggerAwaitingJoinFailure = function(joinedTopic, message) {
      var callback, topic, _i, _len, _ref, _ref1, _results;
      _ref = this.awaitingJoins;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], topic = _ref1.topic, callback = _ref1.callback;
        if (!(topic === joinedTopic)) {
          continue;
        }
        if (typeof callback === "function") {
          callback(err, message);
        }
        _results.push(this.awaitingJoins.splice(index, 1));
      }
      return _results;
    };

    return Socket;

  })();

}).call(this);
